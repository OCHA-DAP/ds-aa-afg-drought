---
title: Indicator Expansion

format:
  html:
    toc: true
    toc-depth: 3
    code-fold: true
    smooth-scroll: true
execute:
  include: true
  echo: true
  warning: false
  message: false
  eval: true
  results: "asis"
  out.width: "100%"
project:
  execute-dir: project
---

## Intro

This document explores a wide variety of climate/remote sensing based indicators and evaluates how well they predict end of season drought based on historical analysis. The indicators are evaluated at each relevant publication month as new data becomes available.

By exploring a wide range of indicators we get a general sense of which indicators may be more important and useful. However,given the messy nature of environmental and large number of publication months and inter-provincial differences assessment requires further simplification and dimensional reduction. For accuracy metrics we then opt to use F1 score and look evaluate the best performing indicators by each publication month and province.

```{r}

aoi_adm1 <- c(
    "Takhar",
    # "Badakhshan",
    # "Badghis",
    "Sar-e-Pul",
    "Faryab"
)

box::use(
    .. / R / blob_connect,
    .. / R / utils,
    seas5 = .. / R / seas5_utils,
    loaders = .. / R / load_funcs
)

box::use(
    dplyr[...],
    readr[...],
    tidyr[...],
    purrr[...],
    glue[...],
    lubridate[...],
    gt[...],
    janitor[...],
    ggh4x[...],
    ggrepel[...],
    sf[...],
    gghdx[...],
    ggplot2[...],
    ggiraph[...],
    stringr[...],
    patchwork[...],
    geoarrow[...],
    cumulus
)
gghdx()
```

```{r}

df_compiled_indicators <- cumulus$blob_read(,
    container = "projects",
    name = "ds-aa-afg-drought/processed/vector/df_all_combined_indicators_v2.parquet"
)

df_indicators_flagged <- df_compiled_indicators |>
    mutate(
        flag = rp_relevant_direction >= 5
    )

# get validation set flagged w/ RP breaches
df_valid_flag <-
    df_indicators_flagged |>
    filter(
        # May ASI has been used as our validation data set
        month(pub_mo_date) == 6 &
            str_detect(parameter, "asi")
    ) |>
    rename(
        valid_flag = flag
    ) |>
    select(
        yr_season, adm1_name, valid_flag
    )


df_env_compare <- df_indicators_flagged |>
    left_join(
        df_valid_flag,
        by = c("yr_season", "adm1_name")
    )
# filter_to_validation_range(df_valid = df_validation_set)

df_env_model <-
    df_env_compare |>
    select(
        date,
        yr_season,
        pub_mo_date,
        pub_mo_label,
        adm1_name,
        parameter,
        value
    ) |>
    filter(
        !parameter %in% c("NDSI_Snow_Cover_min", "NDSI_Snow_Cover_max", "era5_land_runoff_max"),
        !str_detect(parameter, "era5_land_volumetric_soil_water_layer_\\d"),

        # already have these from ERA land up to 2024 rather than 2020
        !(parameter %in% c("total_precipitation", "mean_2m_air_temperature"))
    )




df_perf_metrics <- df_env_compare |>
    mutate(
        TP = flag & valid_flag,
        TN = !flag & !valid_flag,
        FP = flag & !valid_flag,
        FN = !flag & valid_flag
    ) |>
    group_by(
        adm1_name,
        pub_mo_label = month(pub_mo_date, label = T, abbr = T),
        parameter
    ) |>
    summarise(
        precision = sum(TP) / (sum(TP) + sum(FP)),
        recall = sum(TP) / (sum(TP) + sum(FN)),
        accuracy = (sum(TP) + sum(TN)) / (sum(TP) + sum(TN) + sum(FP) + sum(FN)),
        .groups = "drop_last"
    ) |>
    mutate(
        f1 = (2 * precision * recall) / (precision + recall),
        # when precision & recall are 0 we get NaN - replace w/ 0 for easier interpretation
        f1 = ifelse(precision == 0 & recall == 0, 0, f1),
        rank_correct = dense_rank(accuracy)
    ) |>
    utils$label_parameters()


```

## Casting a Wide Net: Exploring 30+ Indicators

-   Below the we look at measured indicators performance. How well does a 5 year RP or greater event measured across each indicator perform in predicting a 5 year RP ASI drought level as measured at the end of March.
    -   The indicators are broken up into 3 major categories (`pre-season`, `mid-season`, `post-season`), based on when each indicator/trigger moment will become available. Note the months represented in the strips on right represent the month the data will be available. Therefore, they are typically put as 1 month after the date the indicator is monitoring. For example NDVI for March will be fully available in April. This is true for all indicators except for the seasonal forecast (`seas5`) where a forecast for the current month is provided at the start of the month the data is published (5th of month)

### Interpreting plots:

Below the performance metrics are given for each parameter and admin unit. The following metrics are calculated:

-   Accuracy
-   Precision
-   Recall

As we are predicting relatively rare events the accuracy metric should be supported by interpretation of precision and recall.

```{r}
aoi_adm1 <- set_names(aoi_adm1, aoi_adm1)

p_metrics_seasonal <-
    aoi_adm1 |>
    map(\(adm_tmp){
        df_perf_metrics |>
            ungroup() |>
            filter(
                adm1_name == adm_tmp
            ) |>
            mutate(
                trigger_type = factor(case_when(
                    pub_mo_label %in% c("Jan", "Feb", "Mar") ~ "Pre-Season",
                    pub_mo_label %in% c("Mar", "Apr", "May") ~ "Mid-Season",
                    pub_mo_label %in% c("Jun", "Jul") ~ "Post-Season"
                ), levels = c("Pre-Season", "Mid-Season", "Post-Season"))
            ) |>
            pivot_longer(cols = precision:accuracy) |>
            filter(pub_mo_label %in% c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul")) |>
            ggplot(
                aes(
                    y = reorder(parameter, value),
                    x = value,
                    color = name
                )
            ) +
            geom_point_interactive(
                aes(tooltip = glue(
                    "parameter: {parameter},
      metric: {name}
      value: {scales::label_percent(accuracy = 1)(value)}"
                )),
                alpha = 0.4
            ) +
            facet_nested(
                rows = vars(trigger_type, pub_mo_label),
                # nest_line = element_line(colour = "red"),
                scales = "free"
            ) +
            scale_x_continuous(labels = scales::label_percent()) +
            scale_y_discrete(expand = c(.05, .05)) +
            labs(
                title = "How well do RS parameters (thresholded - 5 year RP) predict cumulative May ASI breaching 5 year RP",
                subtitle = glue("{adm_tmp} Province")
            ) +
            theme(
                # strip.text = element_text(angle=90),
                ggh4x.axis.nestline = element_line(linetype = 2),
                panel.border = element_rect(fill = NA, color = "grey"),
                legend.title = element_blank(),
                axis.text.y = element_text(size = 6),
                axis.title.x = element_blank(),
                axis.title.y = element_blank(),
                plot.title = element_text(size = 9),
                plot.subtitle = element_text(size = 8), strip.background = element_rect(fill = "lightgrey")
            )
    })
```

```{r}
#| fig.height: 10

girafe(ggobj = p_metrics_seasonal$Faryab)
```

```{r}
#| fig.height: 9

girafe(ggobj = p_metrics_seasonal$`Sar-e-Pul`)
```

```{r}
#| fig.height: 9

girafe(ggobj = p_metrics_seasonal$Takhar)
```

### Initial takeaways

-   All indicators pre-season indicators perform weakly in January across all admin units

-   `SEAS5` (seasonal forecast) is the best pre-season indicator that we have the earliest in `Feb` in most provinces

-   More indicators become better predictors in March (labelled as pre-season, but not really sufficient leadtime for agricultural activities and operational leadtimes received).

-   In March SEAS5 prediction for MAM is still the most predictive preciptiation indicator we have.

-   By March/April, soil moisture looks very promising as well as other combinations with snow indicators and precipitation

-   From April onwards observed precipitation becomes more predictive. With CHIRPS leading over ERA5 by a usually a minor except in Bagdhis where ERA5 is much more performant.

## Performance Simplification (across metrics)

Due to the class imbalance, we are more concerned with the precision & recall balance than accuracy metric. We can further simplify precision & recall with the `f1 score` (harmonic mean of precision and recall) for predicting end of season ASI (dekad 3 may).

```{r}
aoi_adm1 <- set_names(aoi_adm1, aoi_adm1)



lp_tile_metrics_seasonal <-
    aoi_adm1 |>
    map(\(adm_tmp){
        # adm_tmp <- "Faryab"
        top5_df <- df_perf_metrics |>
            filter(adm1_name == adm_tmp) |>
            filter(pub_mo_label %in% c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul")) |>
            group_by(pub_mo_label) |>
            slice_max(order_by = f1, n = 5, with_ties = FALSE) |>
            mutate(top5_flag = TRUE) |>
            select(pub_mo_label, parameter, top5_flag)

        df_temp <- df_perf_metrics |>
            ungroup() |>
            filter(
                adm1_name == adm_tmp
            ) |>
            mutate(
                trigger_type = factor(case_when(
                    pub_mo_label %in% c("Jan", "Feb", "Mar") ~ "Pre-Season",
                    pub_mo_label %in% c("Mar", "Apr", "May") ~ "Mid-Season",
                    pub_mo_label %in% c("Jun", "Jul") ~ "Post-Season"
                ), levels = c("Pre-Season", "Mid-Season", "Post-Season")),
                f1_good = f1 >= 0.6
            ) |>
            filter(pub_mo_label %in% c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul")) |>
            left_join(top5_df, by = c("pub_mo_label", "parameter")) |>
            mutate(
                top5_flag = ifelse(is.na(top5_flag), FALSE, top5_flag),
                highlight = f1_good | top5_flag,
                color_label = case_when(
                    f1_good ~ "1",
                    top5_flag ~ "2",
                    TRUE ~ "3"
                )
            )
        #   group_by(pub_mo_label) |>
        #    mutate(
        #   # f1_rank = rank(desc(f1), ties.method = "first"),  # rank descending
        #   f1_rank = dense_rank(-f1),  # rank descending
        #   num_f1_good = sum(f1_good),
        #   highlight = case_when(
        #     f1_good ~ TRUE,
        #     !f1_good & f1_rank <= (3 - num_f1_good) ~ TRUE,
        #     TRUE ~ FALSE
        #   ),
        #   color_label = case_when(
        #     f1_good ~ "1",
        #     highlight ~ "2",
        #     TRUE ~ "3"
        #   )
        # ) |>
        # ungroup()

        df_temp |>
            ggplot(
                aes(
                    x = pub_mo_label,
                    y = parameter,
                    fill = f1
                )
            ) +
            geom_tile_interactive(
                aes(
                    tooltip = glue(
                        "parameter: {parameter},
          f1: {scales::label_percent(accuracy = 1)(f1)}"
                    )
                    # color= color_label,
                ),
                alpha = 1
                # linewidth =1
            ) +
            geom_tile(
                data = df_temp |>
                    filter(highlight),
                aes(color = color_label), linewidth = 1, alpha = 1
            ) +
            scale_color_manual(
                values = c(
                    "1" = hdx_hex("tomato-dark"),
                    "2" = hdx_hex("tomato-light")
                )
            ) +
            #       geom_tile(
            #   data = df_temp|>
            #     filter(f1>=0.6),
            #     # group_by(pub_mo_label) |>
            #     # slice_max(
            #     #   f1, n= 3
            #     # ),
            #     fill = NA, color = "red", linewidth = 1
            # )+
            labs(
                title = "How well do RS parameters (thresholded - 5 year RP) predict cumulative May ASI breaching 5 year RP",
                subtitle = glue("{adm_tmp} Province")
            ) +
            theme(
                # strip.text = element_text(angle=90),
                # ggh4x.axis.nestline = element_line(linetype = 2),
                panel.border = element_rect(fill = NA, color = "grey"),
                legend.title = element_blank(),
                axis.text.y = element_text(size = 6),
                axis.title.x = element_blank(),
                axis.title.y = element_blank(),
                plot.title = element_text(size = 9),
                plot.subtitle = element_text(size = 8),
                strip.background = element_rect(fill = "lightgrey")
            )
    })
```

```{r}
#| fig.height: 9

girafe(ggobj = lp_tile_metrics_seasonal$`Sar-e-Pul`, height_svg = 6)
```

```{r}
#| fig.height: 9

girafe(ggobj = lp_tile_metrics_seasonal$Takhar, height_svg = 6)
```

```{r}
#| fig.height: 6

girafe(ggobj = lp_tile_metrics_seasonal$Faryab, height_svg = 6)
```

## Indicator Consolidation

Casting the wide net reveals some interesting relationship and gives us an indication of what indicators could be useful, but let's try to simplify and distill this further.

As a first step we can remove redundant indicators. For example since we already have NDSI_mean, let's get rid of `NDSI_min`, `NDSI_max` since they just cloud the interpretation. Additionally we have aggregated the top layers of soil moisture into `era5_land_soil_moisture_1m` so we can get rid of the individual soil moisture depth layers

```{r}
gdf_adm1 <- cumulus::blob_read(
    name = "ds-aa-afg-drought/raw/vector/afg_admbnda_agcho_adm1.parquet",
    container = "projects", as_data_frame = FALSE
) |>
    st_as_sf()


#' NTR: this whole weighting idea never went anywhere and I decide not to use
#' it. Nonetheless, the non-weighted original results are still calculated
#' well i SHOULD really simplify code by removing entire thing, but would be good
#' to rememmber i tried it somewhere.
df_pin <- cumulus::blob_read(
    name = "ds-aa-afg-drought/raw/vector/HNRP_2025_PiN_Targets_Severity.xlsx",
    container = "projects"
)

df_pin_wts <- df_pin |>
    clean_names() |>
    filter(province %in% aoi_adm1) |>
    group_by(province) |>
    summarise(
        fsc_pin_wt = sum(pin_fsc)
    ) |>
    rename(
        adm1_name = "province"
    )

df_area_wt_table <- gdf_adm1 |>
    clean_names() |>
    filter(adm1_en %in% aoi_adm1) %>%
    mutate(
        area_wt = as.numeric(st_area(.))
    ) |>
    st_drop_geometry() |>
    select(adm1_name = adm1_en, adm1_pcode, area_wt) |>
    left_join(
        df_pin_wts
    ) |>
    mutate(
        area_x_fsc_wt = area_wt * fsc_pin_wt
    )


generalize_f1 <- function(df, aoi, weight = NULL) {
    df_agg <- df |>
        filter(
            adm1_name %in% aoi
        ) |>
        group_by(
            pub_mo_label, parameter, parameter_label
        )
    if (is.null(weight)) {
        ret <- df_agg |>
            summarise(
                across(
                    .cols = c("f1", "precision", "recall"), \(x) mean(x, na.rm = T)
                ),
                .groups = "drop"
            )
    }
    if (!is.null(weight)) {
        ret <- df_agg |>
            summarise(
                across(
                    .cols = c("f1", "precision", "recall"), \(x) weighted.mean(x, , w = !!sym(weight), na.rm = T)
                ),
                .groups = "drop"
            )
    }
    ret
}

wt_set <- list(
    NO_WT = NULL,
    AREA_WT = "area_wt",
    AREA_FSC_PIN_WT = "area_x_fsc_wt"
)
df_perf_metrics_w_wt <- df_perf_metrics |>
    left_join(df_area_wt_table)


df_perf_metrics_w_wt_filt <- df_perf_metrics_w_wt |>
    filter(
        !parameter %in% c(
            "NDSI_Snow_Cover_min",
            "NDSI_Snow_Cover_max",
            "era5_land_runoff_max"
        ),
        !str_detect(parameter, "era5_land_volumetric_soil_water_layer_\\d")
    )

perf_param <- c("precision", "recall", "f1")[3]

f1_good_threshold <- 0.6
lp_f1_combined <- imap(
    wt_set,
    \(wt_temp, nmt){
        dft <- generalize_f1(
            df = df_perf_metrics_w_wt_filt,
            aoi = c("Takhar", "Sar-e-Pul", "Faryab"),
            weight = wt_temp
        )
        top5_df <- dft |>
            group_by(pub_mo_label) |>
            slice_max(order_by = f1, n = 5, with_ties = FALSE) |>
            mutate(top5_flag = TRUE) |>
            select(pub_mo_label, parameter, top5_flag)

        dft_filt <- dft |>
            filter(
                pub_mo_label %in% c("Feb", "Mar", "Apr", "May", "Jun")
            ) |>
            group_by(pub_mo_label) |>
            mutate(
                f1_good = !!sym(perf_param) >= f1_good_threshold
            ) |>
            left_join(top5_df, by = c("pub_mo_label", "parameter")) |>
            mutate(
                top5_flag = ifelse(is.na(top5_flag), FALSE, top5_flag),
                highlight = f1_good | top5_flag,
                color_label = case_when(
                    f1_good ~ "1",
                    top5_flag ~ "2",
                    TRUE ~ "3"
                )
            ) |>
            ungroup()

        # ,
        #     # f1_rank = rank( -!!sym(perf_param), ties.method = "mean"),  # rank descending
        #     f1_rank = dense_rank( -!!sym(perf_param)),  # rank descending
        #     num_f1_good = sum(f1_good),
        #     highlight = case_when(
        #       f1_good ~ TRUE,
        #       !f1_good & f1_rank <= (3 - num_f1_good) ~ TRUE,
        #       TRUE ~ FALSE
        #     ),
        #     color_label = case_when(
        #       f1_good ~ "1",
        #       highlight ~ "2",
        #       TRUE ~ "3"
        #     )
        #   ) |>
        # ungroup()
        # mutate(
        #   f1_gte_0.5 = !!sym(perf_param)>=0.5
        # )

        subtitle_tmp <- switch(nmt,
            "NO_WT" = "Unweighted",
            "AREA_WT" = "Weighted by province area",
            "AREA_FSC_PIN_WT" = "Weighted by province area & FSC PiN"
        )

        dft_filt |>
            ggplot(
                aes(
                    x = pub_mo_label,
                    y = parameter_label,
                    fill = !!sym(perf_param)
                )
            ) +
            geom_tile_interactive(
                aes(tooltip = glue(
                    "parameter: {parameter},
      F1 score: {scales::label_percent(accuracy = 1)(f1)}"
                )),
                alpha = 1
            ) +
            labs(
                title = subtitle_tmp
            ) +
            # geom_tile(
            #   data = dft_filt |>
            #     group_by(pub_mo_label) |>
            #     slice_max(
            #       !!sym(perf_param),
            #       n= 5
            #     ),
            #   # aes(color = f1_gte_0.5),
            #   fill = NA,
            #   show.legend=F,
            #   # color = "red",
            #   linewidth = 1
            # )+
            scale_fill_viridis_c() +
            geom_tile(
                data = dft_filt |>
                    filter(highlight),
                aes(color = color_label), linewidth = 1
            ) +
            # scale_color_manual(
            #   values = c(
            #     "TRUE"= hdx_hex("tomato-hdx"),
            #     "FALSE"="grey"
            #     )
            # )+
            scale_color_manual(
                values = c(
                    "1" = hdx_hex("tomato-dark"),
                    "2" = "grey"
                )
            ) +
            theme(
                # ggh4x.axis.nestline = element_line(linetype = 2),
                panel.border = element_rect(fill = NA, color = "grey"),
                legend.title = element_blank(),
                axis.text.y = element_text(size = 10),
                axis.title.x = element_blank(),
                axis.title.y = element_blank(),
                strip.background = element_rect(fill = "lightgrey")
            )
    }
)



ldf_f1_combined <- imap(
    wt_set,
    \(wt_temp, nmt){
        wt_label <- switch(nmt,
            "NO_WT" = "Unweighted",
            "AREA_WT" = "Weighted by province area",
            "AREA_FSC_PIN_WT" = "Weighted by province area & FSC PiN"
        )
        dft <- generalize_f1(
            df = df_perf_metrics_w_wt |>
                filter(
                    !parameter %in% c("NDSI_Snow_Cover_min", "NDSI_Snow_Cover_max"),
                    !str_detect(parameter, "era5_land_volumetric_soil_water_layer_\\d")
                ),
            aoi = c("Takhar", "Sar-e-Pul", "Faryab"),
            weight = wt_temp
        )
        dft |>
            filter(
                pub_mo_label %in% c("Feb", "Mar", "Apr", "May", "Jun")
            ) |>
            mutate(
                f1_gte_0.5 = f1 >= 0.4,
                weight_type = wt_label
            )
    }
) |>
    list_rbind()
```

```{r}

# lp_f1_combined$NO_WT +
#   lp_f1_combined$AREA_WT +
#   lp_f1_combined$AREA_FSC_PIN_WT + plot_layout(nrow = 1)+
#   plot_annotation(title= "Average F1 Score Across Provinces")

# So just go separate
# girafe(ggobj =lp_f1_combined$AREA_FSC_PIN_WT)
girafe(
    ggobj = lp_f1_combined$NO_WT +
        labs(
            title = "Average F1 Score Across Provinces Per Activation Moment"
        )
)
# girafe(ggobj =lp_f1_combined$AREA_WT)

```

```{r}
#| eval: false
#| fig.height: 9

# no longer in AOI
# lp_tile_metrics_seasonal$Badakhshan
```

```{r}
#| eval: false

# this looks like left over code to be removed
lp_metric <-
    aoi_adm1 |>
    map(\(adm_tmp){
        df_perf_metrics |>
            filter(adm1_name == adm_tmp) |>
            pivot_longer(cols = precision:accuracy) |>
            ggplot(
                aes(
                    x = reorder(parameter, value),
                    y = value,
                    color = name
                )
            ) +
            geom_point_interactive(
                aes(tooltip = glue(
                    "parameter: {parameter},
      metric: {name}
      value: {scales::label_percent(accuracy = 1)(value)}"
                )),
                alpha = 0.4
            ) +
            coord_flip() +
            scale_y_continuous(labels = scales::label_percent()) +
            labs(
                title = "How well do RS parameters (thresholded - 5 year RP) predict cumulative May ASI breaching 5 year RP",
                subtitle = glue("{adm_tmp} Province")
            ) +
            theme(
                legend.title = element_blank(),
                axis.text.y = element_text(size = 6),
                axis.title.x = element_blank(),
                axis.title.y = element_blank(),
                plot.title = element_text(size = 9),
                plot.subtitle = element_text(size = 8)
            )
    })


girafe(ggobj = lp_metric$Takhar)
```

```{r}

df_metrics_simple <- df_perf_metrics |>
    filter(adm1_name != "Badghis", adm1_name != "Badakhshan") |>
    filter(
        pub_mo_label %in% c("Feb", "Mar", "Apr", "May", "Jun"),
        !str_detect(parameter, "runoff_max"),
        !parameter %in% c("NDSI_Snow_Cover_min", "NDSI_Snow_Cover_max", "total_precipitation"),
        !str_detect(parameter, "era5_land_volumetric_soil_water_layer_\\d")
    ) |>
    # filter(!is.nan(f1)) |>
    utils$label_parameters()





df_metrics_filt <- df_metrics_simple |>
    filter(
        pub_mo_label %in% c("Feb", "Mar", "Apr", "May", "Jun"),
        !str_detect(parameter, "runoff_max"),
        !parameter %in% c("NDSI_Snow_Cover_min", "NDSI_Snow_Cover_max", "total_precipitation"),
        !str_detect(parameter, "era5_land_volumetric_soil_water_layer_\\d")
    )

df_top_metrics_label <- df_metrics_filt |>
    mutate(
        f1_lgl = f1 > 0.5
    ) |>
    group_by(adm1_name, pub_mo_label) |>
    mutate(
        num_gte = sum(f1_lgl)
    ) |>
    arrange(
        adm1_name, pub_mo_label, desc(f1)
    ) |>
    mutate(
        include = row_number(),
        rank = dense_rank(-f1)
    ) |>
    # print(n=25) |>
    filter(
        rank %in% c(1:3)
        # & f1_lgl
    ) |>
    ungroup()

# df_top_metrics_label |>
#   filter(adm1_name == "Sar-e-Pul")

df_metrics_top3 <- df_metrics_filt |>
    group_by(adm1_name, pub_mo_label) |>
    slice_max(f1, n = 3, with_ties = T)


viridis_colors <- viridisLite::viridis(15, option = "A")

c25 <- c(
    "green4",
    "#E31A1C",
    "dodgerblue2",
    "#6A3D9A", # ndsi purple
    "#FF7F00", # orange
    "skyblue2",
    "gold1",
    "#FB9A99", # lt pink
    "palegreen2",
    "#CAB2D6", # lt purple
    "#FDBF6F", # lt orange
    "gray70",
    "khaki2",
    "maroon",
    "orchid1",
    "deeppink1",
    "blue1", # soil mositure
    "steelblue4",
    "darkturquoise", "green1", "yellow4", "yellow3",
    "darkorange4", "brown"
)



p_ts_f1 <- df_metrics_top3 |>
    ggplot(
        aes(
            x = pub_mo_label, y = f1
        )
    ) +
    geom_point(
        data = df_metrics_filt,
        alpha = 0.5, color = "darkgrey"
    ) +
    geom_point(
        aes(color = parameter_label)
    ) +
    geom_label_repel(
        data = df_metrics_top3,
        aes(
            label = parameter_label,
            fill = parameter_label
        ),
        max.overlaps = 20,
        color = "black"
    ) +
    # scale_fill_brewer(palette = "Set3")+
    scale_fill_manual(values = c25) +
    labs(
        # title = "F1 Scores: How well do indicators predict worst end of season ASI values",
        title = "F1 Scores: By Province & Trigger Moment",
        subtitle = "Only Top indicators labelled"
    ) +
    scale_color_manual(values = c25) +
    facet_wrap(~adm1_name) +
    theme(
        panel.grid.major.x = element_line(color = "black"),
        legend.position = "none"
    )
```

The below plot displays similar information as the above, but we have kept the provinces separated and show the f1 score of each indicator more clearly on the y-axis. The only indicators that are labelled in this plot are the ones that were ranked with the top 3 f1 scores per activation moment/province. More than 3 labels per vertical activation moment line occurs when there are ties in the top 3 ranking.

```{r}
#| fig.height: 9

ggplot(
    df_metrics_filt,
    aes(
        x = pub_mo_label, y = f1
    )
) +
    geom_point(
        alpha = 0.5,
        color = "darkgrey"
    ) +
    geom_point(
        data = df_top_metrics_label,
        aes(color = parameter_label)
    ) +
    geom_label_repel(
        data = df_top_metrics_label,
        aes(
            label = parameter_label,
            fill = parameter_label
        ),
        alpha = 0.5,
        size = 1.8, label.padding = 0.1,
        max.overlaps = 20,
        color = "black"
    ) +
    # scale_fill_brewer(palette = "Set3")+
    scale_fill_manual(values = c25) +
    scale_color_manual(values = c25) +
    labs(
        x = "Activation moment/ publication month",
        title = "Predictiveness of Indicators by Province and Trigger Timing (F1 Score)",
        subtitle = "Only Top 3 Ranking Indicators Labelled Per Publication Month and Province"
    ) +
    facet_wrap(~adm1_name, ncol = 1) +
    theme(
        panel.grid.major.x = element_line(color = "black"),
        legend.position = "none",
        plot.title = element_text(size = 10),
        plot.subtitle = element_text(size = 10)
    )

```

```{r}
#| fig.height: 9
#| eval: false

# -   F1 by pub mo plot w/ out mixed forecat observational
ggplot(
    df_metrics_filt |>
        filter(
            parameter != "mam_mixed_seas_observed"
        ),
    aes(
        x = pub_mo_label, y = f1
    )
) +
    geom_point(
        alpha = 0.5,
        color = "darkgrey"
    ) +
    geom_point(
        data = df_top_metrics_label |>
            filter(parameter != "mam_mixed_seas_observed"),
        aes(color = parameter_label)
    ) +
    geom_label_repel(
        data = df_top_metrics_label |>
            filter(parameter != "mam_mixed_seasonal"),
        aes(
            label = parameter_label,
            fill = parameter_label
        ),
        alpha = 0.5,
        size = 1.8, label.padding = 0.1,
        max.overlaps = 20,
        color = "black"
    ) +
    # scale_fill_brewer(palette = "Set3")+
    scale_fill_manual(values = c25) +
    scale_color_manual(values = c25) +
    labs(
        x = "Activation moment/ publication month",
        title = "Predictiveness of Indicators by Province and Trigger Timing (F1 Score)",
        subtitle = "Only Top 3 Indicators Labelled Per Publication Month and Province"
    ) +
    facet_wrap(~adm1_name, ncol = 1) +
    theme(
        panel.grid.major.x = element_line(color = "black"),
        legend.position = "none"
    )

```

```{r}
#| eval: false

# the above plot provides best summary of this chapter in IMO and a decent indication of what is to come. This table further helps some of the accompanying narrartive final indicator selection for April but not sure where to put it
#  CHIRPS better perf than ERA5 in April, but all other months show ERA5 precip
# Snow cover NDSI is included, but it was shifted to ERA5 for simplification
# Many complications with MODIS although it could have been a good option as well.
# the addition of mixed-seasonal removes ERA 5 snow cover from FAryab plot.
df_metrics_filt |>
    group_by(pub_mo_label, parameter, parameter_label) |>
    summarise(
        f1 = mean(f1),
        rank = mean(dense_rank(-f1))
    ) |>
    group_by(
        pub_mo_label
    ) |>
    mutate(
        rank2 = dense_rank(-f1)
    ) |>
    arrange(pub_mo_label, rank2) |>
    slice_max(f1, n = 7) |>
    print(n = 33)


# faryab w/ best april metrics by far ,  NDSI (MODIS) not as good in others
df_metrics_filt |>
    mutate(
        d_rank = dense_rank(-f1)
    ) |>
    filter(
        pub_mo_label == "Apr"
    ) |>
    arrange(adm1_name, desc(f1)) |>
    print(n = 48)

```

## Appendix

```{r}
#| eval: false
#| include: false

lp_ndsi_params <- map(
    wt_set,
    \(wt_temp){
        dft <- generalize_f1(
            df = df_perf_metrics_w_wt |>
                filter(
                    parameter %in% c("NDSI_Snow_Cover_min", "NDSI_Snow_Cover_mean", "NDSI_Snow_Cover_max")
                ),
            aoi = c("Takhar", "Sar-e-Pul", "Faryab"),
            weight = wt_temp
        )
        dft_filt <- dft |>
            filter(
                pub_mo_label %in% c("Feb", "Mar", "Apr", "May", "Jun")
            ) |>
            mutate(
                f1_gte_0.5 = f1 >= 0.4
            )

        dft_filt |>
            ggplot(
                aes(
                    x = parameter,
                    y = f1
                )
            ) +
            geom_point() +
            coord_flip() +
            facet_wrap(~pub_mo_label) +
            theme(
                # strip.text = element_text(angle=90),
                ggh4x.axis.nestline = element_line(linetype = 2),
                panel.border = element_rect(fill = NA, color = "grey"),
                legend.title = element_blank(),
                axis.text.y = element_text(size = 10),
                axis.title.x = element_blank(),
                axis.title.y = element_blank(),
                # plot.title = element_text(size =9),
                # plot.subtitle = element_text(size =8),
                strip.background = element_rect(fill = "lightgrey")
            )
    }
)

lp_ndsi_params$NO_WT
```

```{r}
#| eval: false
#| include: false


# quick gut check on era5 snow fall - can add to appendix during cleanup
df_era_snow <- df_environmental_yr_adj
# filter(
#   yr_season >= df_validation_range[1],
#   yr_season <= df_validation_range[2],
#   adm1_name %in% aoi_adm1
# ) |>
df_era_snow <- df_env_compare |>
    # this group_by() -> filter() step is just to grab the last dekad per month
    # for ASI & VHI, the rest of the data is monthly time-step so it has no
    # effect on them
    group_by(
        adm1_name, parameter, pub_mo_date
    ) |>
    filter(
        date == max(date)
    ) |>
    ungroup() |>
    filter(
        # FEB ERA SNOW
        month(pub_mo_date) == 2
        # regex to detect snow_cover or snow melt
        & str_detect(parameter, "era.*snow(_cover|melt_sum)") |
            # ASI
            (str_detect(parameter, "asi") & month(pub_mo_date) == 6)
    )

df_era_snow_wide <- df_era_snow |>
    pivot_wider(
        id_cols = c(yr_date, adm1_name),
        names_from = parameter,
        values_from = value
    )


df_era_snow_wide |>
    group_by(
        adm1_name
    ) |>
    summarise(
        cor(asi, era5_land_snow_cover)
    )

# snow melt correlations are negative... so feb pub (jan data) does negatively correlate to ASI
# more Jan snow melt less agg stress... could look more into ERA5 snowmelt var, but strange
df_era_snow_wide |>
    group_by(
        adm1_name
    ) |>
    summarise(
        cor(asi, era5_land_snowmelt_sum)
    )
df_env_filt_flag |>
    count(parameter) |>
    print(n = 23)

df_era5_land_rps_wide <- df_env_filt_flag |>
    filter(
        # (month(pub_mo_date)==2 & str_detect(parameter, "era.*snow(_cover|melt_sum)"))
        (month(pub_mo_date) == 2 & str_detect(parameter, "^era5_land")) |
            # ASI
            (str_detect(parameter, "asi") & month(pub_mo_date) == 6)
    ) |>
    pivot_wider(
        id_cols = c(yr_date, adm1_name),
        names_from = parameter,
        values_from = rp_relevant_direction
    )

df_era5_land_rps_wide |>
    ggplot(
        aes(x = era5_land_snow_cover, y = asi)
    ) +
    geom_point()



thresh <- 5
df_era5_land_rps_wide |>
    filter(adm1_name %in% c("Takhar", "Faryab", "Sar-e-Pul")) |>
    mutate(
        perf_class = case_when(
            era5_land_surface_runoff_sum >= thresh & asi >= thresh ~ "TP",
            era5_land_surface_runoff_sum >= thresh & asi < thresh ~ "FP",
            era5_land_surface_runoff_sum <= thresh & asi > thresh ~ "FN",
            era5_land_surface_runoff_sum <= thresh & asi <= thresh ~ "TN"
        )
    ) |>
    glimpse() |>
    ggplot(
        aes(x = era5_land_surface_runoff_sum, y = asi, color = perf_class)
    ) +
    geom_point() +
    scale_color_manual(
        values = c(
            "TP" = hdx_hex("mint-hdx"),
            "TN" = hdx_hex("mint-light"),
            "FN" = hdx_hex("tomato-hdx"),
            "FP" = hdx_hex("tomato-light")
        )
    ) +
    geom_vline(xintercept = thresh) +
    geom_hline(yintercept = thresh) +
    scale_x_log10() +
    scale_y_log10() +
    facet_wrap(~adm1_name) +
    theme(
        panel.border = element_rect(color = "grey", fill = NA)
    ) +
    labs(
        title = "Performance: Feb ERA5 Surface Runoff Sum Predicting End of Seasson ASI",
        caption = "High return periods runoff corresponds to deficit of runoff where as high RP ASI corresponds to higher vegetative stress (end of May)"
    )


# df_era_snow_esa |>
#   ggplot(aes(x= )
```

```{r pointSystem}
#| eval: false
#| include: false

# Abandoned idea for z-score composite aggregation.
# Point system - you need 4 points
#
# Feb: SEAS5 : 4 points Mar: - Observational Rainfall (CHIRPS): 2 points - Observed Soil Moisture : 2 points - NDSI or SWE: 2 points April: - Observed Rainfall CHIRPS OR ERA5: 4 points - NDSI: 2 points - SWE: 2 points May: - ASI: 4 points - VHI: 2 points - Soil Moisture: 2 points
#
# Jun: - ASI: 4 - VHI: 2 - Soil Moisture 2

df_ps <- df_env_compare |>
    utils$label_parameters() |>
    mutate(
        ps = case_when(
            str_detect(parameter, "NDSI|SWE") & pub_mo_label == "Mar" ~ "SNOW_COMBINED",
            str_detect(parameter, "era5_land_volumetric_soil") ~ "soil_moisture",
            str_detect(parameter, "NDSI") & pub_mo_label != "Mar" ~ "NDSI",
            # str_detect(ps,"chirps_cumu|era5_cumu_precip") ~"observational_chirps_era5",
            str_detect(parameter, "cumu_chirps|cumu_era5_land_total_precipitation") ~ "cumu_observational_chirps_era5",
            .default = parameter
        )
    )




df_rps_composite <- df_ps |>
    group_by(
        pub_mo_label, yr_season, adm1_name, ps
    ) |>
    slice_max(
        rp_relevant_direction,
        n = 1, with_ties = F
    ) |>
    summarise(
        rp = max(rp_relevant_direction, na.rm = T),
        # rp_flag = rp>=5,
    ) |>
    mutate(
        rp_flag = case_when(
            ps == "SEAS5-MAM" ~ rp >= 5,
            ps == "soil_moisture" ~ rp >= 10,
            ps == "SNOW_COMBINED" ~ rp >= 10,
            ps == "NDSI" ~ rp >= 10,
            ps == "cumu_observational_chirps_era5" ~ rp >= 3,
            ps == "asi" ~ rp >= 5,
            ps == "vhi" ~ rp >= 5,
            .default = NA_real_
        )
    ) |>
    ungroup()


df_pts_added |>
    filter(pub_mo_label == "Mar") |>
    print(n = 30)

df_pts_added <- df_rps_composite |>
    filter(pub_mo_label != "Jan") |>
    mutate(
        pts1 = case_when(

            # Feb - Just SEAS5
            pub_mo_label == "Feb" & ps == "SEAS5-MAM" & rp_flag ~ 4,
            pub_mo_label == "Feb" & ps == "SEAS5-MAM" & !rp_flag ~ 0,

            # March - soil moisture, snow, rainfall
            pub_mo_label == "Mar" & ps == "soil_moisture" & rp_flag ~ 2,
            pub_mo_label == "Mar" & ps == "soil_moisture" & !rp_flag ~ 0,
            pub_mo_label == "Mar" & ps == "SNOW_COMBINED" & rp_flag ~ 2,
            pub_mo_label == "Mar" & ps == "SNOW_COMBINED" & !rp_flag ~ 0,
            pub_mo_label == "Mar" & ps == "cumu_observational_chirps_era5" & rp_flag ~ 2,
            pub_mo_label == "Mar" & ps == "cumu_observational_chirps_era5" & !rp_flag ~ 0,

            # april Snow/ rainfall
            pub_mo_label == "Apr" & ps == "NDSI" & rp_flag ~ 2,
            pub_mo_label == "Apr" & ps == "NDSI" & !rp_flag ~ 0,
            pub_mo_label == "Apr" & ps == "SWE_inst" & rp_flag ~ 2,
            pub_mo_label == "Apr" & ps == "SWE_inst" & !rp_flag ~ 0,
            pub_mo_label == "Apr" & ps == "cumu_observational_chirps_era5" & rp_flag ~ 4,
            pub_mo_label == "Apr" & ps == "cumu_observational_chirps_era5" & !rp_flag ~ 0,

            # May
            pub_mo_label == "May" & ps == "asi" & rp_flag ~ 4,
            pub_mo_label == "May" & ps == "asi" & !rp_flag ~ 0,
            pub_mo_label == "May" & ps == "vhi" & rp_flag ~ 2,
            pub_mo_label == "May" & ps == "vhi" & !rp_flag ~ 0,
            pub_mo_label == "May" & ps == "soil_moisture" & rp_flag ~ 2,
            pub_mo_label == "May" & ps == "soil_moisture" & !rp_flag ~ 0,


            # june = ASI, VHI, soil moisture
            pub_mo_label == "Jun" & ps == "asi" & rp_flag ~ 4,
            pub_mo_label == "Jun" & ps == "asi" & !rp_flag ~ 0,
            pub_mo_label == "Jun" & ps == "vhi" & rp_flag ~ 2,
            pub_mo_label == "Jun" & ps == "vhi" & !rp_flag ~ 0,
            pub_mo_label == "Jun" & ps == "soil_moisture" & rp_flag ~ 2,
            pub_mo_label == "Jun" & ps == "soil_moisture" & !rp_flag ~ 0,
            # ps %in% ps_considered ~0,
            .default = NA
        )
    )






df_pts_added |>
    filter(pub_mo_label %in% c("Feb", "Mar", "Apr", "May", "Jun")) |>
    group_by(pub_mo_label, adm1_name, yr_season) |>
    summarise(
        pts1 = sum(pts1, na.rm = T),
        pts_flag = pts1 >= 4, .groups = "drop_last"
    ) |>
    # count(pts1)
    summarise(
        ar = mean(pts_flag),
        rp = 1 / ar
    ) |>
    print(
        n = 25
    )

df_pts_added |>
    filter(adm1_name != "Badghis") |>
    filter(pub_mo_label %in% c(
        "Feb",
        "Mar",
        "Apr",
        # "May",
        "Jun"
    )) |>
    group_by(pub_mo_label, yr_season, adm1_name) |>
    summarise(
        pts1 = sum(pts1, na.rm = T),
        pts_flag = pts1 >= 4, .groups = "drop_last"
    ) |>
    group_by(
        pub_mo_label, yr_season
    ) |>
    summarise(
        pts_flag = any(pts_flag)
    ) |>
    group_by(pub_mo_label) |>
    # count(pts1)
    summarise(
        ar = mean(pts_flag),
        rp = 1 / ar
    ) |>
    print(
        n = 25
    )

df_pts_added |>
    filter(!adm1_name %in% c("Badghis", "Badakhshan")) |>
    filter(pub_mo_label %in%
        c(
            # "Feb",
            # "Mar",
            # "Apr",
            "May",
            "Jun"
        )) |>
    group_by(pub_mo_label, yr_season, adm1_name) |>
    summarise(
        pts1 = sum(pts1, na.rm = T),
        pts_flag = pts1 >= 4, .groups = "drop_last"
    ) |>
    group_by(
        pub_mo_label, yr_season
    ) |>
    summarise(
        pts_flag = any(pts_flag)
    ) |>
    group_by(yr_season) |>
    summarise(
        pts_flag = any(pts_flag)
    ) |>
    # count(pts1)
    summarise(
        ar = mean(pts_flag),
        rp = 1 / ar
    ) |>
    print(
        n = 25
    )


df_pts_monitoring_historical <- df_pts_added |>
    filter(
        pub_mo_label %in% c("Feb", "Mar", "Apr", "May", "Jun"), !is.na(pts1)
    )



df_pts_w_activation <- df_pts_monitoring_historical |>
    group_by(
        pub_mo_label, yr_season, adm1_name
    ) |>
    mutate(
        activate = sum(pts1) >= 4,
        activate_color = ifelse(activate & pts1 > 0, "yes", "no")
    )

mos_monitoring <- list(
    "Feb" = "Feb",
    "Mar" = "Mar",
    "Apr" = "Apr",
    # "May" = "May",
    "Jun" = "Jun"
)


lp_observational_tile <- map(
    mos_monitoring,
    \(mo_tmp){
        df_pts_w_activation |>
            filter(
                adm1_name != "Badghis",
                pub_mo_label == mo_tmp
            ) |>
            ggplot(
                aes(
                    x = yr_season,
                    y = ps,
                    fill = pts1,
                    color = activate_color
                )
            ) +
            geom_tile(linewidth = 1) +
            scale_color_manual(
                values = c(
                    "yes" = "red",
                    "no" = NULL
                )
            ) +
            scale_fill_gradient() +
            facet_grid(
                rows = vars(adm1_name),
                scales = "free"
            )
    }
)

lp_observational_tile$Apr
lp_observational_tile$Mar

```

```{r runOff}
#| eval: false
#| include: false
# i need to have a little look at this runoff var

df_env_filt |>
    filter(
        str_detect(parameter, "runoff")
    ) |>
    count(parameter)

df_runoff <- df_env_filt |>
    filter(
        str_detect(parameter, "runoff_max")
    )

df_asi <- df_env_filt |>
    filter(str_detect(parameter, "asi"), pub_mo_label == "Jun") |>
    rename(
        asi = value
    ) |>
    select(
        adm1_name, pub_yr_date, asi,
        rp_asi = rp_relevant_direction
    )

df_runoff_asi <- df_runoff |>
    filter(
        # pub_mo_label == "Feb",
        adm1_name == "Takhar"
    ) |>
    left_join(
        df_asi,
        by = c("pub_yr_date", "adm1_name")
    ) |>
    group_by(adm1_name, pub_mo_label) |>
    mutate(
        anom_runoff = value - mean(value, na.rm = T),
        anom_asi = asi - mean(asi, na.rm = T)
    ) |>
    select(
        adm1_name, date, pub_mo_date, pub_mo_label, anom_runoff, anom_asi, value, asi,
        rp_runoff = rp_relevant_direction, rp_asi
    )

df_runoff_asi |>
    ggplot(
        aes(x = anom_runoff, y = anom_asi, color = rp_runoff)
    ) +
    geom_point_interactive(
        aes(tooltip = glue("date: {date}
                       value:{value}"))
    ) +
    scale_color_continuous(trans = scales::log10_trans()) +
    facet_wrap(~pub_mo_label, scales = "free")

runoff_rp_threshold <- 3
asi_rp_threshold <- 3
p_runoff_rp_scatter <- df_runoff_asi |>
    mutate(
        rp_class = case_when(
            rp_runoff >= runoff_rp_threshold &
                rp_asi >= asi_rp_threshold ~ "TP",
            rp_runoff < runoff_rp_threshold &
                rp_asi < asi_rp_threshold ~ "TN",
            rp_runoff >= runoff_rp_threshold &
                rp_asi < asi_rp_threshold ~ "FP",
            rp_runoff < runoff_rp_threshold &
                rp_asi >= asi_rp_threshold ~ "FN"
        )
    ) |>
    ggplot(
        aes(x = rp_runoff, y = rp_asi, color = rp_class)
    ) +
    geom_vline(
        xintercept = runoff_rp_threshold
    ) +
    geom_hline(
        yintercept = asi_rp_threshold
    ) +
    geom_point_interactive(
        aes(tooltip = glue("date: {date}
                       runoff:{value}
                       asi: {asi}
                       RP ASI: {rp_asi}
                       RP runoff: {rp_runoff}"))
    ) +
    # scale_color_continuous(trans = scales::log10_trans())+
    facet_wrap(~pub_mo_label, scales = "free")

girafe(ggobj = p_runoff_rp_scatter)


```
